// mqtt.js
// MQTT Client ƒë·ªÉ nh·∫≠n tr·∫°ng th√°i thi·∫øt b·ªã real-time
let mqttClient = null;

// Track last update time ƒë·ªÉ tr√°nh spam
const lastUpdateTime = {
    fan: 0,
    air_conditioner: 0,
    light: 0
};

// Track device connection status
let deviceConnected = true;
let chartUpdateInterval = null;

// H√†m ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi thi·∫øt b·ªã - TH√äM V√ÄO WINDOW
window.checkDeviceConnection = function(sensorData) {
    if (!sensorData) return false;
    
    console.log("üîç Checking device connection:", sensorData);
    
    // Ki·ªÉm tra d·ª±a tr√™n d·ªØ li·ªáu sensor
    const isDisconnected = 
        (sensorData.temperature === 0 || sensorData.temperature === null) && 
        (sensorData.humidity === 0 || sensorData.humidity === null) && 
        (sensorData.light === 0 || sensorData.light === null);
    
    // Ki·ªÉm tra timestamp
    const currentTime = new Date().getTime();
    const dataTime = sensorData.timestamp ? new Date(sensorData.timestamp).getTime() : currentTime;
    const isDataStale = (currentTime - dataTime) > 30000;
    
    const connected = !(isDisconnected || isDataStale);
    console.log(`üì° Device connected: ${connected}`);
    
    return connected;
}

// K·∫øt n·ªëi MQTT
function connectMQTT() {
    try {
        // S·ª≠ d·ª•ng MQTT over WebSocket
        mqttClient = mqtt.connect('ws://localhost:9001', {
            username: 'esp32',
            password: '123'
        });

        mqttClient.on('connect', () => {
            console.log('MQTT WebSocket connected');
            mqttClient.subscribe('device/status');
        });

        mqttClient.on('message', (topic, message) => {
            if (topic === 'device/status') {
                const text = message.toString();
                console.log('Received device status from MQTT:', text);
                
                try {
                    let device, status;
                    if (text.includes(":")) {
                        [device, status] = text.split(":");
                    } else {
                        const obj = JSON.parse(text);
                        device = obj.device;
                        status = obj.status;
                    }
                    
                    // Normalize status to uppercase
                    status = (status || "").toUpperCase();
                    
                    // C·∫≠p nh·∫≠t switch t∆∞∆°ng ·ª©ng
                    updateDeviceSwitch(device, status);
                } catch (e) {
                    console.error('Error parsing MQTT status:', e);
                }
            }
        });

        mqttClient.on('error', (err) => {
            console.error('MQTT error:', err);
        });
    } catch (err) {
        console.error('Failed to connect MQTT:', err);
    }
}

// H√†m ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi thi·∫øt b·ªã
function checkDeviceConnection(sensorData) {
    if (!sensorData) return false;
    
    // Ki·ªÉm tra d·ª±a tr√™n d·ªØ li·ªáu sensor
    // N·∫øu t·∫•t c·∫£ gi√° tr·ªã = 0 ho·∫∑c kh√¥ng h·ª£p l·ªá, coi nh∆∞ disconnected
    const isDisconnected = 
        (sensorData.temperature === 0 || sensorData.temperature === null) && 
        (sensorData.humidity === 0 || sensorData.humidity === null) && 
        (sensorData.light === 0 || sensorData.light === null);
    
    // Ho·∫∑c ki·ªÉm tra timestamp (n·∫øu d·ªØ li·ªáu qu√° c≈©)
    const currentTime = new Date().getTime();
    const dataTime = sensorData.timestamp ? new Date(sensorData.timestamp).getTime() : currentTime;
    const isDataStale = (currentTime - dataTime) > 30000; // 30 gi√¢y
    
    return !(isDisconnected || isDataStale);
}

// H√†m d·ª´ng c·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì
function stopChartUpdates() {
    if (chartUpdateInterval) {
        clearInterval(chartUpdateInterval);
        chartUpdateInterval = null;
    }
    
    // D·ª´ng animation bi·ªÉu ƒë·ªì n·∫øu c√≥
    if (window.pauseChart) {
        window.pauseChart();
    }
}

// H√†m hi·ªÉn th·ªã tr·∫°ng th√°i disconnected
function showDisconnectedStatus() {
    // Th√™m indicator v√†o UI
    const statusIndicator = document.getElementById('device-status') || createStatusIndicator();
    statusIndicator.innerHTML = 'üî¥ Thi·∫øt b·ªã ng·∫Øt k·∫øt n·ªëi';
    statusIndicator.style.color = '#ff4444';
    
    // Hi·ªÉn th·ªã gi√° tr·ªã m·∫∑c ƒë·ªãnh
    const tempEl = document.getElementById("temp");
    const humiEl = document.getElementById("humi");
    const lightEl = document.getElementById("light");
    
    if (tempEl) tempEl.innerText = "-- ‚ÑÉ";
    if (humiEl) humiEl.innerText = "-- %";
    if (lightEl) lightEl.innerText = "-- lux";
}

// H√†m hi·ªÉn th·ªã tr·∫°ng th√°i connected
function showConnectedStatus() {
    const statusIndicator = document.getElementById('device-status');
    if (statusIndicator) {
        statusIndicator.innerHTML = 'üü¢ Thi·∫øt b·ªã ƒë√£ k·∫øt n·ªëi';
        statusIndicator.style.color = '#00c853';
    }
}

// T·∫°o indicator n·∫øu ch∆∞a c√≥
function createStatusIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'device-status';
    indicator.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 1000;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;
    document.body.appendChild(indicator);
    return indicator;
}

// C·∫≠p nh·∫≠t switch d·ª±a tr√™n tr·∫°ng th√°i t·ª´ MQTT
function updateDeviceSwitch(device, status) {
    const deviceMap = {
        'fan': 0,
        'air_conditioner': 1,
        'light': 2
    };
    
    const switchIndex = deviceMap[device];
    if (switchIndex !== undefined) {
        const switches = document.querySelectorAll(".devices input[type=checkbox]");
        if (switches[switchIndex]) {
            const isOn = status === "ON";
            const currentState = switches[switchIndex].checked;
            const now = Date.now();
            
            console.log(`MQTT received: ${device} = ${status}, current switch state: ${currentState ? 'ON' : 'OFF'}`);
            
            // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu:
            // 1. Tr·∫°ng th√°i th·ª±c s·ª± kh√°c
            // 2. Ch∆∞a c·∫≠p nh·∫≠t trong 500ms (tr√°nh spam)
            if (currentState !== isOn && (now - lastUpdateTime[device]) > 500) {
                switches[switchIndex].checked = isOn;
                lastUpdateTime[device] = now;
                console.log(`‚úÖ MQTT: Updated ${device} switch from ${currentState ? 'ON' : 'OFF'} to ${isOn ? 'ON' : 'OFF'}`);
            } else if (currentState === isOn) {
                console.log(`‚è≠Ô∏è MQTT: ${device} switch already correct (${isOn ? 'ON' : 'OFF'}), no update needed`);
            } else {
                console.log(`‚è≠Ô∏è MQTT: ${device} update too frequent, skipping`);
            }
            
            // Re-enable switch sau khi nh·∫≠n ƒë∆∞·ª£c MQTT update
            switches[switchIndex].disabled = false;
            
            // ·∫®n spinner khi nh·∫≠n MQTT update
            const spinnerMap = {
                'fan': document.getElementById("fan-spinner"),
                'air_conditioner': document.getElementById("ac-spinner"),
                'light': document.getElementById("light-spinner")
            };
            if (spinnerMap[device]) {
                spinnerMap[device].style.display = "none";
            }
        }
    }
}

// K·∫øt n·ªëi t·ªõi backend ƒë·ªÉ load d·ªØ li·ªáu sensor m·ªõi nh·∫•t ƒë·ªãnh k·ª≥
// K·∫øt n·ªëi t·ªõi backend ƒë·ªÉ load d·ªØ li·ªáu sensor m·ªõi nh·∫•t ƒë·ªãnh k·ª≥
async function fetchLatestSensor() {
    try {
        const res = await fetch("http://localhost:3000/api/sensor/latest");
        const data = await res.json();

        if (data) {
            // Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi - S·ª¨A TH√ÄNH window.checkDeviceConnection
            const isConnected = window.checkDeviceConnection(data);
            
            if (!isConnected && deviceConnected) {
                // Chuy·ªÉn t·ª´ connected sang disconnected
                console.log("‚ö†Ô∏è Device disconnected - stopping chart updates");
                deviceConnected = false;
                stopChartUpdates();
                showDisconnectedStatus();
            } else if (isConnected && !deviceConnected) {
                // Chuy·ªÉn t·ª´ disconnected sang connected
                console.log("‚úÖ Device reconnected - resuming chart updates");
                deviceConnected = true;
                showConnectedStatus();
            }
            
            // Ch·ªâ c·∫≠p nh·∫≠t dashboard n·∫øu device connected
            if (deviceConnected) {
                if (typeof window !== 'undefined' && typeof window.updateDashboard === 'function') {
                    window.updateDashboard(data);
                } else {
                    const tempEl = document.getElementById("temp");
                    const humiEl = document.getElementById("humi");
                    const lightEl = document.getElementById("light");
                    if (tempEl) tempEl.innerText = data.temperature + "‚ÑÉ";
                    if (humiEl) humiEl.innerText = data.humidity + "%";
                    if (lightEl) lightEl.innerText = data.light + " lux";
                }
            } else {
                // N·∫øu disconnected, v·∫´n hi·ªÉn th·ªã gi√° tr·ªã nh∆∞ng v·ªõi style kh√°c
                const tempEl = document.getElementById("temp");
                const humiEl = document.getElementById("humi");
                const lightEl = document.getElementById("light");
                if (tempEl) tempEl.innerText = data.temperature + "‚ÑÉ";
                if (humiEl) humiEl.innerText = data.humidity + "%";
                if (lightEl) lightEl.innerText = data.light + " lux";
            }
        }
    } catch (err) {
        console.error("L·ªói fetch sensor:", err);
        // N·∫øu fetch l·ªói, coi nh∆∞ disconnected
        if (deviceConnected) {
            deviceConnected = false;
            stopChartUpdates();
            showDisconnectedStatus();
        }
    }
}

// G·ªçi API ƒë·ªÉ ƒëi·ªÅu khi·ªÉn thi·∫øt b·ªã
async function controlDevice(device, action) {
    try {
        const res = await fetch("http://localhost:3000/api/device/control", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ device, action })
        });
        const result = await res.json();
        console.log("Device control result:", result);
        return { ok: true };
    } catch (err) {
        console.error("L·ªói control device:", err);
        return { ok: false };
    }
}

// ƒê·ªìng b·ªô tr·∫°ng th√°i c√¥ng t·∫Øc v·ªõi backend
async function syncDeviceStatus() {
    try {
        const res = await fetch("http://localhost:3000/api/device/status");
        const status = await res.json();
        console.log("Received device status:", status);
        
        // Map: index -> device key
        const deviceKeys = ["fan", "air_conditioner", "light"];
        document.querySelectorAll(".devices input[type=checkbox]").forEach((el, idx) => {
            const key = deviceKeys[idx];
            const on = (status && status[key]) === "ON";
            console.log(`Setting ${key} to ${on ? 'ON' : 'OFF'} (was ${el.checked ? 'ON' : 'OFF'})`);
            
            // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu tr·∫°ng th√°i th·ª±c s·ª± kh√°c
            if (el.checked !== on) {
                el.checked = !!on;
                console.log(`Updated ${key} switch to reflect actual device status`);
            }
        });
    } catch (err) {
        console.error("L·ªói ƒë·ªìng b·ªô tr·∫°ng th√°i thi·∫øt b·ªã:", err);
    }
}

// G·∫Øn event cho c√°c switch
// Map device -> spinner ID
const spinnerMap = {
    fan: document.getElementById("fan-spinner"),
    air_conditioner: document.getElementById("ac-spinner"),
    light: document.getElementById("light-spinner")
};

document.querySelectorAll(".devices input[type=checkbox]").forEach((el, idx) => {
    el.addEventListener("change", async () => {
        let deviceName = idx === 0 ? "fan" : idx === 1 ? "air_conditioner" : "light";
        const desiredChecked = el.checked;
        const desiredAction = desiredChecked ? "ON" : "OFF";

        // Revert switch ƒë·ªÉ ch·ªù l·ªánh
        el.checked = !desiredChecked;

        // Hi·ªÉn th·ªã spinner
        if (spinnerMap[deviceName]) {
            spinnerMap[deviceName].style.display = "inline-block";
        }

        // Disable switch
        el.disabled = true;
        
        const result = await controlDevice(deviceName, desiredAction);
        if (!result.ok) {
            el.disabled = false;
            if (spinnerMap[deviceName]) {
                spinnerMap[deviceName].style.display = "none"; // ·∫©n spinner n·∫øu th·∫•t b·∫°i
            }
            return;
        }

        // Timeout: n·∫øu kh√¥ng nh·∫≠n MQTT update sau 5s
        setTimeout(() => {
            if (el.disabled) {
                el.disabled = false;
                if (spinnerMap[deviceName]) {
                    spinnerMap[deviceName].style.display = "none";
                }
            }
        }, 5000);
    });
});

// Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì v·ªõi c∆° ch·∫ø interval
function initializeChartWithInterval() {
    // N·∫øu b·∫°n ƒëang d√πng bi·ªÉu ƒë·ªì real-time
    chartUpdateInterval = setInterval(() => {
        if (deviceConnected && window.addChartData) {
            // Ch·ªâ th√™m ƒëi·ªÉm d·ªØ li·ªáu n·∫øu device connected
            // H√†m fetchLatestSensor s·∫Ω g·ªçi addChartData
        }
    }, 3000);
}

// C·∫≠p nh·∫≠t d·ªØ li·ªáu sensor m·ªói 3s
document.addEventListener('DOMContentLoaded', () => {
    // T·∫°o status indicator
    createStatusIndicator();
    
    // Load d·ªØ li·ªáu ban ƒë·∫ßu
    fetchLatestSensor();
    
    // C·∫≠p nh·∫≠t sensor m·ªói 3s nh∆∞ng c√≥ ki·ªÉm tra tr·∫°ng th√°i
    setInterval(fetchLatestSensor, 3000);
    
    // ƒê·ªìng b·ªô tr·∫°ng th√°i thi·∫øt b·ªã khi trang t·∫£i
    syncDeviceStatus();
    
    // K·∫øt n·ªëi MQTT ƒë·ªÉ nh·∫≠n tr·∫°ng th√°i real-time
    connectMQTT();
    
    // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì
    initializeChartWithInterval();
    
    // T·∫Øt ƒë·ªìng b·ªô ƒë·ªãnh k·ª≥ ƒë·ªÉ tr√°nh conflict v·ªõi MQTT real-time
    // setInterval(syncDeviceStatus, 5000); // ƒê√£ comment out
});